# Kindle: A Comprehensive Framework for Exploring OS-Architecture Interplay in Hybrid Memory Systems

Kindle, based on gem5 and gemOS, to explore and prototype research ideas in hybrid memory systems crossing the hardware-software boundaries, and perform comprehensive empirical evaluation. Kindle provides mechanisms to realize process persistence in hybrid memory systems while facilitating analysis of different design challenges and alternatives.

## For framework evaluation
==================================

1> Execute **run.sh** to perform the preparation and simulation part of Kindle. **run.sh** executes **run_preparation.sh** to  generate a disk image with memory access trace of sample benchmark program **quick\_sort**. It also executes **run_simulation.sh** to build gem5 and gemOS kernel.

2> After starting the gem5 simulation, We interact with gem5 telnet port using **expect** Linux utility

3> Simulation output is available in default **output** folder set in **run_Kindle.sh**

## More Information on working and background
=================================

## 1. Creating disk image and template code
=======================================

1> **run.sh** executes **run_preparation.sh** to  generate disk image with memory access trace of sample benchmark program **quick\_sort**.

2> Change *BENCH\_PATH* , *BENCH\_NAME* , *BENCH\_ARGS* variables in **run_preparation.sh** to create disk image for another benchmark program. These variables are used in *execlp* call in **benchmark\_run.c**

3> **run_preparation.sh** executes **benchmark\_run** to generate trace of provided benchmark program (quick\_sort). The tracefile is cauptured in **pinatrace.out** file (for PIN tracing set /proc/sys/kernel/yama/ptrace\_scope to 0). The file size of ~22 GB for **quick\_sort**

4> **run_preparation.sh** executes **format\_file.py** python program to format records in **pinatrace.out** to create **data.csv**. Size of **data.csv** is ~12GB for **quick\_sort**

5> Python script also creates template code for gemOS, **init.c**

6> **run_preparation.sh** then creates a *data.img* file equal to the size of **data.csv**. Then **readfile** loads **data.csv** to *data.img*, which is used as disk image for gem5.

## 2. Build gem5 using instructions 
=====================================

1> The **gem5** folder contains **hybrid memory** modifications, **run_simulation.sh** builds gem5 by executing following command inside **gem5**

`scons build/X86/gem5.opt -j8`

For more information on gem5 building, following below link,

https://www.gem5.org/documentation/general\_docs/building

## 3. Build gemOS kernel
==============================

1> **run_simulation.sh** build **gemOS** kernel after copying **init.c** generated by preparation part to **user/init.c** 

2> user space code is writte in **user/init.c** , users can modify it accordingly

3> Use the template **init.c** generated in previous step for user space.

4>  **run_simulation.sh** run **make** inside gemOS folder

## 4. Run Kindle
======================================

1> **data.img** file cotains program memory trace, use it as disk image.

2> **run_Kindle.sh** starts gem5 and takes **output** folder as argument to save gem5 stats, create an output folder and pass complete path as follows.

3> Now **gem5** starts and you need to connect to gem5 using telnet in a different terminal

**telnet localhost 3456**, the port number is printed by gem5 as " Listening for connections on port 3456"

4> The terminal after connecting to "telnet" will show gemOS prompt as below

**GemOS#**

5> To run your user program in **init.c**, type **init** command on **GemOS#** as below

**GemOS# init**

6> The init program executes and you can see output

7> To exit **gemOS** run, **exit** command as below on **GemOS#**

**GemOS# exit**



